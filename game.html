<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Telegraph Runner ‚Äî Platformer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#041026; --panel:#07293a; --accent:#22d3ee; --muted:#9fb0c1; --good:#34d399; --bad:#f87171; --ui-bg: rgba(255,255,255,0.03);}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#04101a,#071026);font-family:Inter, Arial, sans-serif;color:#e6f6fb}
  .wrap{max-width:1100px;margin:12px auto;padding:12px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:6px 10px}
  h1{font-family:'Press Start 2P',monospace;font-size:18px;margin:0;color:var(--accent)}
  .hud{display:flex;gap:10px;align-items:center;font-weight:700;flex-wrap:wrap}
  .pill{background:var(--ui-bg);padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);color:var(--muted);font-size:0.86rem}
  #gameCanvas{display:block;margin:12px auto;border-radius:8px;background:linear-gradient(180deg,#092233,#071026);box-shadow:0 14px 40px rgba(0,0,0,0.6);max-width:100%}
  .controls{max-width:1100px;margin:10px auto;color:var(--muted);font-size:0.95rem;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
  .btn {background:var(--accent);color:#071026;border:0;padding:8px 10px;border-radius:8px;font-weight:700;text-decoration:none;cursor:pointer}
  .small{font-size:0.9rem;color:var(--muted)}
  footer{max-width:1100px;margin:18px auto;color:var(--muted);font-size:0.85rem;text-align:center}
  /* Mobile controller */
  .mobile-controls{display:flex;gap:8px;justify-content:center;margin-top:8px;touch-action:none}
  .control-btn{background:rgba(255,255,255,0.04);color:#e6f6fb;border:1px solid rgba(255,255,255,0.05);padding:12px;border-radius:10px;min-width:60px;text-align:center;font-weight:800;user-select:none}
  .control-btn:active{transform:translateY(2px)}
  .overlay{position:fixed;inset:0;background:rgba(2,6,14,0.6);backdrop-filter:blur(2px);z-index:90;display:none}
  .modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#0b2633;border:1px solid rgba(255,255,255,0.06);padding:18px;border-radius:10px;color:#e6f6fb;min-width:260px;z-index:100;display:none}
  @media (max-width:640px){
    .hud{justify-content:center}
    .mobile-controls{display:flex}
  }
  @media (min-width:641px){
    .mobile-controls{display:none}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Telegraph Runner</h1>
      <div class="hud" aria-hidden="false">
        <div class="pill">Level: <span id="hud-level">1</span></div>
        <div class="pill">Score: <span id="hud-score">0</span></div>
        <div class="pill">Lives: <span id="hud-lives">3</span></div>
        <div class="pill">Stations: <span id="hud-stations">0/0</span></div>
      </div>
    </header>

    <canvas id="gameCanvas" width="1000" height="560" aria-label="Telegraph Runner Game"></canvas>

    <div class="controls">
      <div class="small">Controls: ‚Üê ‚Üí to move, ‚Üë / Space to jump, Z/X or on-screen Shoot. Connect all stations to win the level.</div>
      <div style="display:flex;gap:8px">
        <button id="startBtn" class="btn">Start / Restart</button>
        <button id="muteBtn" class="btn">üîä Sound</button>
        <a class="btn" href="index.html">‚Ü© Back</a>
      </div>
    </div>

    <div class="mobile-controls" role="toolbar" aria-label="Mobile controls">
      <div class="control-btn" id="leftBtn">‚óÄ</div>
      <div class="control-btn" id="rightBtn">‚ñ∂</div>
      <div class="control-btn" id="jumpBtn">‚§í</div>
      <div class="control-btn" id="shootBtn">‚óè</div>
    </div>

    <div style="height:12px"></div>
    <footer>Made for COM216 ‚Äî Hayden Klahs ¬∑ <span id="highscoreText">High Score: 0</span></footer>
  </div>

  <div id="overlay" class="overlay"></div>
  <div id="modal" class="modal" role="dialog" aria-modal="true"></div>

<script>
/*
  Telegraph Runner - compact but robust platformer
  - Prevents crashes with safe guards
  - AudioContext is created lazily (on first user interaction)
  - Mobile buttons emit synthetic input events
*/

// ---- Utility & audio ----
let audioCtx = null;
let soundEnabled = true;
function ensureAudioUnlocked() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  } catch (e) {
    audioCtx = null;
  }
}
function beep(frequency = 600, duration = 0.08, type = 'sine') {
  if (!soundEnabled) return;
  ensureAudioUnlocked();
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = frequency;
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start(now);
  o.stop(now + duration + 0.02);
}

// unlock audio on first interaction
['touchstart','mousedown','keydown'].forEach(ev=>{
  window.addEventListener(ev, function unlock(){
    ensureAudioUnlocked();
    if (audioCtx && audioCtx.state === 'suspended' && audioCtx.resume) {
      audioCtx.resume().catch(()=>{});
    }
    // only run once
    ['touchstart','mousedown','keydown'].forEach(e=>window.removeEventListener(e,unlock));
  }, {once:true});
});

// ---- Game Setup ----
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const HUD = {
  level: document.getElementById('hud-level'),
  score: document.getElementById('hud-score'),
  lives: document.getElementById('hud-lives'),
  stations: document.getElementById('hud-stations'),
  highscore: document.getElementById('highscoreText')
};

let W = canvas.width;
let H = canvas.height;
function resizeCanvas() {
  const bounding = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  // keep internal resolution high but cap width for performance
  const cssWidth = Math.min(window.innerWidth - 24, 1100);
  const cssHeight = Math.max(320, Math.min(600, window.innerHeight * 0.62));
  canvas.style.width = cssWidth + 'px';
  canvas.style.height = cssHeight + 'px';
  canvas.width = Math.round(cssWidth * dpr);
  canvas.height = Math.round(cssHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  W = cssWidth;
  H = cssHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// ---- Input ----
const input = { left:false, right:false, up:false, shoot:false };
const keys = {
  ArrowLeft: 'left', ArrowRight: 'right', ArrowUp: 'up', ' ': 'up',
  w:'up', W:'up', ArrowDown:'down',
  z:'shoot', Z:'shoot', x:'shoot', X:'shoot'
};
window.addEventListener('keydown', e => {
  const k = keys[e.key];
  if (k) { input[k] = true; e.preventDefault(); }
});
window.addEventListener('keyup', e => {
  const k = keys[e.key];
  if (k) { input[k] = false; e.preventDefault(); }
});

// mobile buttons
[['leftBtn','left'],['rightBtn','right'],['jumpBtn','up'],['shootBtn','shoot']].forEach(([id,action])=>{
  const el = document.getElementById(id);
  if (!el) return;
  const press = (e) => { input[action] = true; e.preventDefault(); };
  const release = (e) => { input[action] = false; e.preventDefault(); };
  el.addEventListener('touchstart', press, {passive:false});
  el.addEventListener('mousedown', press);
  el.addEventListener('touchend', release);
  el.addEventListener('mouseup', release);
  el.addEventListener('mouseleave', release);
  el.addEventListener('touchcancel', release);
});

// ---- Game Entities ----
function rectsOverlap(a,b){
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

let game = null;

function createLevel(levelNum=1){
  // scale for screen size
  const scale = Math.max(0.6, Math.min(1.2, W / 1000));
  // Platforms: floor + some platforms
  const platforms = [
    {x:0,y:H-40,w:W,h:40},
    {x:W*0.15,y:H-160,w:W*0.25,h:16},
    {x:W*0.55,y:H-240,w:W*0.3,h:16},
    {x:W*0.38,y:H-340,w:W*0.2,h:16}
  ];
  // player
  const player = {
    x:40, y:H-120, w:36*scale, h:48*scale,
    vx:0, vy:0, speed: 260*scale, jumpPower: 520*scale,
    onGround:false, canDoubleJump:false
  };
  // enemies
  const enemies = [
    {x:W*0.6,y:H-56,w:32,h:32,vx:-80,patrol:[W*0.45,W*0.85]},
    {x:W*0.28,y:H-176,w:30,h:30,vx:60,patrol:[W*0.15,W*0.43]}
  ];
  // stations (pickups to "connect")
  const stations = [
    {x:W*0.2,y:H-200,w:28,h:36,connected:false},
    {x:W*0.7,y:H-300,w:28,h:36,connected:false}
  ];
  // bullets
  const bullets = [];
  return { levelNum, scale, platforms, player, enemies, stations, bullets,
           score:0, lives:3, time:0, stationsConnected:0, running:false, lastTime:0 };
}

// ---- Main Loop ----
function startGame() {
  if (game && game.running) resetGame();
  game = createLevel(1);
  updateHUD();
  game.running = true;
  game.lastTime = performance.now();
  beep(800,0.06,'square');
  requestAnimationFrame(loop);
}

function resetGame() {
  if (!game) game = createLevel(1);
  game.player.x = 40; game.player.y = H-120; game.player.vx=0; game.player.vy=0;
  game.enemies.forEach((e,i)=>{ e.vx = e.vx>0?Math.abs(e.vx):-Math.abs(e.vx); });
  game.bullets.length = 0;
  game.score = 0;
  game.lives = 3;
  game.stations.forEach(s=>s.connected=false);
  game.stationsConnected = 0;
  updateHUD();
}

function endGame(win=false){
  game.running = false;
  showModal(win ? "Level Complete! üéâ" : "Game Over");
  if (win) beep(1000,0.12,'sine');
  else beep(120,0.14,'sawtooth');
}

// safe clamped physics step
function loop(ts){
  if (!game) return;
  const dt = Math.min(0.035, (ts - game.lastTime) / 1000);
  game.lastTime = ts;
  update(dt);
  render();
  if (game.running) requestAnimationFrame(loop);
}

function update(dt){
  const p = game.player;
  // horizontal movement
  const accel = 1200;
  if (input.left) p.vx = -p.speed;
  else if (input.right) p.vx = p.speed;
  else p.vx = 0;

  // jumping
  if (input.up) {
    if (p.onGround) {
      p.vy = -p.jumpPower;
      p.onGround = false;
      p.canDoubleJump = true;
      beep(750,0.07);
    } else if (p.canDoubleJump) {
      p.vy = -p.jumpPower * 0.9;
      p.canDoubleJump = false;
      beep(820,0.06);
    }
    // prevent repeated auto-jump on long press: we'll set a tiny lock until released
    input.up = false; // makes jump require repeated taps/presses
  }

  // gravity
  p.vy += 1400 * dt; // gravity
  // integrate
  p.x += p.vx * dt;
  p.y += p.vy * dt;

  // screen bounds
  if (p.x < 0) p.x = 0;
  if (p.x + p.w > W) p.x = W - p.w;

  // platform collisions - simple resolution
  p.onGround = false;
  for (const plat of game.platforms) {
    // only check when overlapping horizontally
    if (p.x + p.w > plat.x && p.x < plat.x + plat.w) {
      // previous position approximation:
      const prevY = p.y - p.vy * dt;
      // landing check
      if (prevY + p.h <= plat.y && p.y + p.h >= plat.y) {
        p.y = plat.y - p.h;
        p.vy = 0;
        p.onGround = true;
        p.canDoubleJump = false;
      }
    }
  }
  // falling off bottom
  if (p.y > H + 200) {
    // lose life and reset position
    game.lives = Math.max(0, game.lives - 1);
    updateHUD();
    if (game.lives <= 0) {
      endGame(false);
      return;
    } else {
      // respawn safely
      p.x = 40; p.y = H-120; p.vy = 0; p.vx = 0;
    }
  }

  // enemies movement & collision with player
  for (const e of game.enemies) {
    // patrol
    if (e.patrol) {
      e.x += e.vx * dt;
      if (e.x < e.patrol[0]) { e.x = e.patrol[0]; e.vx = Math.abs(e.vx); }
      if (e.x > e.patrol[1]) { e.x = e.patrol[1]; e.vx = -Math.abs(e.vx); }
    }
    // collision
    if (rectsOverlap({x:p.x,y:p.y,w:p.w,h:p.h}, e)) {
      // knockback and life loss, but guard to avoid repeated immediate life loss
      if (!e._recentHit) {
        game.lives = Math.max(0, game.lives - 1);
        updateHUD();
        e._recentHit = true;
        setTimeout(()=>{ e._recentHit = false; }, 900);
        // small knockback
        p.vx = (p.x < e.x) ? -240 : 240;
        p.vy = -220;
        beep(180,0.12,'sawtooth');
        if (game.lives <= 0) { endGame(false); return; }
      }
    }
  }

  // bullets update
  for (let i = game.bullets.length - 1; i >= 0; --i) {
    const b = game.bullets[i];
    b.x += b.vx * dt;
    b.life -= dt;
    // remove if expired or offscreen
    if (b.life <= 0 || b.x < -30 || b.x > W + 30) { game.bullets.splice(i,1); continue; }
    // check enemy hit
    for (let j = game.enemies.length - 1; j >= 0; --j) {
      const en = game.enemies[j];
      if (rectsOverlap({x:b.x,y:b.y,w:b.w,h:b.h}, en)) {
        // destroy enemy, increase score
        game.score += 50;
        beep(1200,0.04,'square');
        game.enemies.splice(j,1);
        game.bullets.splice(i,1);
        break;
      }
    }
  }

  // station collisions (connect)
  for (const s of game.stations) {
    if (!s.connected && rectsOverlap({x:p.x,y:p.y,w:p.w,h:p.h}, s)) {
      s.connected = true;
      game.stationsConnected += 1;
      game.score += 100;
      beep(1000,0.09,'triangle');
      updateHUD();
      if (game.stationsConnected >= game.stations.length) {
        // level complete
        endGame(true);
        return;
      }
    }
  }

  // shooting (shoot only when pressed; require short cooldown)
  if (input.shoot && !game._shootCooldown) {
    fireBullet();
    game._shootCooldown = 0.22; // seconds
    input.shoot = false; // require repeated presses
  }
  if (game._shootCooldown) game._shootCooldown = Math.max(0, game._shootCooldown - dt);

  game.time += dt;
  // small time-based updates could go here
}

function fireBullet(){
  const p = game.player;
  const dir = (input.right ? 1 : input.left ? -1 : 1);
  const b = {
    x: p.x + p.w/2,
    y: p.y + p.h/2 - 6,
    w: 8, h: 6,
    vx: dir * 640,
    life: 1.2
  };
  game.bullets.push(b);
  beep(1200,0.04,'square');
}

// ---- Rendering ----
function render(){
  // clear
  ctx.clearRect(0,0,W,H);
  // background subtle grid or vignette
  // draw platforms
  ctx.fillStyle = '#092b3a';
  for (const plat of game.platforms) {
    ctx.fillStyle = '#0f3b4d';
    ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
    // top highlight
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fillRect(plat.x, plat.y, plat.w, 3);
  }
  // draw stations
  for (const s of game.stations) {
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.fillStyle = s.connected ? '#34D399' : '#f2d49b';
    ctx.fillRect(0,0,s.w,s.h);
    ctx.fillStyle = '#0b2a3a';
    ctx.fillRect(4,6,s.w-8,s.h-12);
    ctx.restore();
  }
  // draw enemies
  for (const e of game.enemies) {
    ctx.fillStyle = '#f87171';
    ctx.fillRect(e.x, e.y, e.w, e.h);
    // eye
    ctx.fillStyle = '#111';
    ctx.fillRect(e.x + e.w*0.6, e.y + e.h*0.2, 4,4);
  }
  // draw player
  const p = game.player;
  ctx.fillStyle = '#67e8f9';
  ctx.fillRect(p.x, p.y, p.w, p.h);
  // visor
  ctx.fillStyle = '#042c35';
  ctx.fillRect(p.x + p.w*0.14, p.y + p.h*0.22, p.w*0.72, p.h*0.26);

  // bullets
  ctx.fillStyle = '#bfefff';
  for (const b of game.bullets) {
    ctx.fillRect(b.x, b.y, b.w, b.h);
  }

  // HUD overlay small
  ctx.fillStyle = 'rgba(0,0,0,0)';
}

// ---- HUD updates ----
function updateHUD(){
  if (!game) return;
  HUD.level.textContent = game.levelNum || 1;
  HUD.score.textContent = game.score || 0;
  HUD.lives.textContent = game.lives || 0;
  HUD.stations.textContent = (game.stationsConnected||0) + '/' + (game.stations?game.stations.length:0);
  // highscore in localStorage
  const hsKey = 'telegraphRunnerHigh';
  const prev = Number(localStorage.getItem(hsKey) || 0);
  if (game.score > prev) {
    localStorage.setItem(hsKey, game.score);
    HUD.highscore.textContent = 'High Score: ' + game.score;
  } else {
    HUD.highscore.textContent = 'High Score: ' + prev;
  }
}

// ---- Modal ----
const overlay = document.getElementById('overlay');
const modal = document.getElementById('modal');
function showModal(text) {
  modal.innerHTML = `<div style="font-weight:800;margin-bottom:12px">${text}</div>
    <div style="display:flex;gap:8px;justify-content:center">
      <button id="modalRestart" class="btn">Restart</button>
      <button id="modalClose" class="btn">Close</button>
    </div>`;
  overlay.style.display = 'block';
  modal.style.display = 'block';
  document.getElementById('modalClose').addEventListener('click', hideModal);
  document.getElementById('modalRestart').addEventListener('click', ()=>{
    hideModal();
    resetGame();
    game.running = true;
    game.lastTime = performance.now();
    requestAnimationFrame(loop);
  });
}
function hideModal(){
  overlay.style.display = 'none';
  modal.style.display = 'none';
}

// ---- Buttons ----
document.getElementById('startBtn').addEventListener('click', () => {
  // ensure audio unlocked
  ensureAudioUnlocked();
  if (!game || !game.running) startGame();
  else { resetGame(); }
});
document.getElementById('muteBtn').addEventListener('click', (e)=>{
  soundEnabled = !soundEnabled;
  e.currentTarget.innerText = soundEnabled ? 'üîä Sound' : 'üîà Muted';
});

// small loop to render HUD frequently
setInterval(()=>{ if (game) updateHUD(); }, 300);

// ---- Prevent crashes: safe initialization ----
(function safeInit(){
  try {
    if (!game) game = createLevel(1);
    // a simple tick to keep canvas alive visually until start
    render();
  } catch (err) {
    console.error('Game init error:', err);
    // show user a friendly message in modal
    showModal('Initialization error ‚Äî please reload the page.');
  }
})();

// ---- Keep game stable when tab hidden ----
document.addEventListener('visibilitychange', () => {
  if (document.hidden && game) {
    // pause game loop but keep running=false to avoid state changes
    game.running = false;
  } else if (!document.hidden && game && !game.running) {
    // resume only if we want
    // don't auto-resume; user should press Start/Restart
  }
});

// ---- Small accessibility: focus on canvas for keyboard ----
canvas.setAttribute('tabindex','0');
canvas.addEventListener('click', ()=>{ canvas.focus(); });

// ---- Prevent accidental dragging on mobile controls ----
document.addEventListener('touchmove', function(e){
  // only prevent when single touch on control buttons
  if (e.target && e.target.classList && e.target.classList.contains('control-btn')) e.preventDefault();
},{passive:false});
</script>
</body>
</html>
